<!-- TOC -->

- [一.外观模式](#外观模式)
- [二.优点](#优点)  
- [三.缺点](#缺点)  
- [四.举例场景](#举例场景)  
- [五.注意事项](#注意事项)  

<!-- /TOC -->

#一.外观模式
### 1.1 简单介绍
- 这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
- 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

### 1.2 目的
降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
 
#二.优点
1. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。

2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。

3. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

#三.缺点
1. 不能很好地限制客户使用子系统类，很容易带来未知风险。

2. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

#四.举例场景
1. 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。

2. 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。

3. 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。

#五.注意事项
- 在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题。

- 在层次化结构中，可以使用外观模式定义系统中每一层的入口。

